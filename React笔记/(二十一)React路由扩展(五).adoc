# React 扩展(五)

## 1. MobX:

=== https://cn.mobx.js.org/[MobX文档]

> - (1) Mobx是一个功能强大，上手非常容易的状态管理工具。
> - (2) Mobx背后的哲学很简单:任何源自应用状态的东西都应该自动地获得。
> - (3) Mobx利用 `getter` 和 `setter` 来收集组件的数据依赖关系，从而在数据发生变化的时 候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更新。

image::[]

=== MobX与redux的区别:

> - (1) MobX写法上更偏向于 `OOP` 。
> - (2) 对一份数据直接进行修改操作，不需要始终返回一个新的数据。
> - (3) 并非单一 `store` ,可以多 `store` 。
> - (4) Redux默认以JavaScript原生对象形式存储数据，而MobX使用可观察对象。

=== MobX优缺点:

=== 优点: 

> - (1) 学习成本小。
> - (2) 面向对象编程, 而且对 TS 友好。

=== 缺点: 

> - (1) 过于自由:Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一。
> - (2) 相关的中间件很少，逻辑层业务整合是问题。


=== MobX的使用: 

> - **(1) `npm install mobx --save` **

> - **(2) `observable` 与 `autorun` **

> - observable
MobX 为现有的数据结构(如对象，数组和类实例)添加了可观察的功能。 通过使用 @observable 装饰器(ES.Next)来给你的类属性添加注解就可以简单地完成这一切。
使用 observable 很像把对象的属性变成excel的单元格。 但和单元格不同的是，这些值不只是原始值，还可以是引用值，比如对象和数组
API 只有在它可以被制作成可观察的数据结构(数组、映射或 observable 对象)时才会成功。对于所有其他值，不会执行转换。
Observable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。

> - autorun
使用 autorun 时，所提供的函数总是立即被触发一次，然后每次它的依赖关系改变时会再次被触发

observable.box(value, options?)
创建一个 observable 的盒子，它用来存储value的 observable 引用。使用 get() 方法可以得到盒子中的当前value，而使用 set() 方法可以更新value。 这是所有其它 observable 创建的基础，但实际中你其实很少能使用到它。

通常盒子会自动地尝试把任何还不是 observable 的新值转换成 observable 。使用 {deep: false} 选项会禁用这项行为。

```jsx
  import { observable , autorun } from 'mobx'
```

```jsx
  //---------------------------------------
  const obj = observable.box(10)
  autorun(() => console.log(obj.get()))
  setTimeout(() => {
      obj.set(20)
      name.set("xiaowang")
  },1000)
  //---------------------------------------
  const name = observable.box("xiaoming")
  autorun(() => console.log(name.get()))
  setTimeout(() =>name.set("xiaohong"),2000)
  //---------------------------------------
  const map = observable.map({name:'zhangsan',age:100})
  autorun(() => console.log(map.get('name')))
  setTimeout(() =>map.set("name","lisi"),3000)
```

image::[]

> - **(2) `action` , `runInAction` 与 `严格模式` **

```jsx
  import {observable, configure, action,runInAction} from 'mobx'
```

configure
用法: configure(options) 。 对活动的 MobX 实例进行全局行为设置。 使用它来改变 MobX 的整体表现。

```jsx
  configure({                   //严格模式， 必须写action
    enforceActions:'always'     //如果是never，可以不写action
  })                            //最好设置always, 防止任意地方修改值， 降低不确定性
```

> - **案例(加减)**

```jsx
  //store.jsx
  const store = observable({
      count: 0,
      add:function(){
          store.count++
      },
      minus:function(){
          store.count--
      },
      addof:function(){
          if(store.count % 2 !== 0){
              store.count++
          }
      },
      asyncAdd:action(function(){
          setTimeout(() =>store.add(),1000)
      })
  },{
      add:action,
      minus:action,
      addof:action,
  })
```

```jsx
  //App.jsx
  class App extends Component {
      state = {
          count:store.count
      }
      componentDidMount() {
        autorun(()=> {
              this.setState({count:store.count});
          })
      }
      render() {
          return (
              <div>
                  <h2>当前和为:{store.count}</h2>
                  <button onClick={()=> store.add()}>+1</button>
                  <button onClick={()=> store.minus()}>-1</button>
                  <button onClick={()=> store.addof()}>奇数+</button>
                  <button onClick={()=> store.asyncAdd()}>异步+</button>
              </div>
          );
      }
  }
```

image::[]


---

=== mobx-react的使用: 

> - (1) react 组件里使用 @observer

> -- observer 函数/装饰器可以用来将 React 组件转变成响应式组件。

> - (2) 可观察的局部组件状态

> -- @observable 装饰器在React组件上引入可观察属性。而不需要通过 React 的冗长和强制性的 setState 机制来管 理。

=== 装饰器安装与配置

> - (1) 支持装饰器

```jsx
  npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env
```

> - (2) 创建 .babelrc

```jsx
  {
    "presets": [
      "@babel/preset-env"
    ],
    "plugins": [
      [
        "@babel/plugin-proposal-decorators",
        {
          "legacy": true
        }
      ]
    ]
  }
```

> - (3) 创建config-overrides.js

```jsx
  const path = require('path')
  const { override, addDecoratorsLegacy } = require('customize-cra')
  function resolve(dir) {
      return path.join(__dirname, dir)
  }
  const customize = () => (config, env) => {
      config.resolve.alias['@'] = resolve('src')
      if (env === 'production') {
          config.externals = {
              'react': 'React',
              'react-dom': 'ReactDOM'
          } }
      return config
  };
  module.exports = override(addDecoratorsLegacy(), customize())
```

> - (4) 安装依赖


```jsx
  npm i customize-cra react-app-rewired
```

> - (5) 修改package.json

```jsx
  ···
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-app-rewired eject"
  },
  ···
```

---

observable & observer

如果你用 React 的话，可以把你的(无状态函数)组件变成响应式组件，方法是在组件上添加 observer 函数/ 装饰器. observer由 mobx-react 包提供的。


runInAction 工具函数
内联动作的缺点是 TypeScript 无法对其进行类型推导，所以你应该为所有的回调函数定义类型。 
你还可以只在动作中运行回调函数中状态修改的部分，而不是为整个回调创建一个动作。 这种模式的优势是它鼓励你不要到处写 action，而是在整个过程结束时尽可能多地对所有状态进行修改


action (动作)
任何应用都有动作。动作是任何用来修改状态的东西。 使用MobX你可以在代码中显式地标记出动作所在的位置。 动作可以有助于更好的组织代码。

inject (mobx-react 包)
相当于Provider 的高阶组件。可以用来从 React 的context中挑选 store 作为 prop 传递给目标组件。

observer
可以用作包裹 React 组件的高阶组件。 在组件的 render 函数中的任何已使用的 observable 发生变化时，组件都会自动重新渲染。 注意 observer 是由 "mobx-react" 包提供的，而不是 mobx 本身。

```jsx
  //store.jsx
  import {observable, configure, action,runInAction} from 'mobx'
```


```jsx
  //App.jsx
  import {inject,observer} from "mobx-react";
```

> - **案例(加减)**

```jsx
  //store.jsx
  class Store{
      @observable count = 0
      @action add(){              /如果是严格模式需要加上 @action 和 runInAction
          this.count++
      }
      @action minus(){
          this.count--
      }
      @action addof(){
          if(this.count % 2 !== 0){
              this.count++
          }
      }
      @action asyncAdd(){
          setTimeout(()=>runInAction(()=>this.count++),1000)
      }
  }
  const store = new Store()
```

```jsx
  //App.jsx
  @inject('store')
  @observer
  class App extends Component {
      render() {
          return (
              <div>
                  <h2>当前和为:{this.props.store.count}</h2>
                  <button onClick={()=> this.props.store.add()}>+1</button>
                  <button onClick={()=> this.props.store.minus()}>-1</button>
                  <button onClick={()=> this.props.store.addof()}>奇数+</button>
                  <button onClick={()=> this.props.store.asyncAdd()}>异步+</button>
              </div>
          );
      }
  }
```

image::[]
